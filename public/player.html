<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Musik-Quiz – Spieler</title>
  <link rel="stylesheet" href="/style.css" />
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <div class="layout">
    <!-- Linke Spalte: Runden/Playlists -->
    <aside class="sidebar">
      <h3 class="h">Playlists (Runden)</h3>
      <div id="roundList" class="list"></div>
      <div class="status">Du bist in Raum <code id="roomCode" class="small">—</code></div>
    </aside>

    <!-- Mitte: Songs -->
    <main class="main">
      <h3 class="h">Runde: <span id="roundName">–</span></h3>
      <div class="status">Aktueller Song: <strong id="currentTitle">–</strong></div>

      <div id="songList" class="songs"></div>

      <div class="row" style="margin-top:12px;">
        <input id="inpCode" placeholder="Raumcode" style="padding:10px;border-radius:10px;border:0;background:#0b1220;color:#fff;" />
        <input id="inpName" placeholder="Dein Name" style="padding:10px;border-radius:10px;border:0;background:#0b1220;color:#fff;" />
        <button id="btnJoin" class="primary">Beitreten</button>
        <button id="btnBuzz">🔔 Buzz</button>
        <button id="btnVoteNext">⏭️ Vote Next</button>
      </div>

      <!-- Audio ohne Controls für Spieler -->
      <audio id="audio" style="display:none"></audio>
      <div id="status" class="status"></div>
    </main>

    <!-- Rechte Spalte: Spieler & Punkte -->
    <aside class="right">
      <h3 class="h">Alle Spieler</h3>
      <div id="players" class="score"></div>
    </aside>
  </div>

  <script>
    // Basics/Refs
    const socket    = io();
    const el        = (s) => document.querySelector(s);
    const roundList = el('#roundList');
    const songList  = el('#songList');
    const audio     = el('#audio');

    // Buttons/Inputs
    const btnJoin     = el('#btnJoin');
    const btnBuzz     = el('#btnBuzz');
    const btnVoteNext = el('#btnVoteNext');
    const inpCode = el('#inpCode');
    const inpName = el('#inpName');

    // State
    let joined  = false;
    let canBuzz = false;   // erst aktiv, wenn Runde/Unlock kommt
    let allowServerPlay = false; // verhindert manuelles Play

    // >>> Auto-Resume beim Laden + Server-Refresh <<<
    try {
      const saved = JSON.parse(localStorage.getItem('mq_player') || 'null');
      if (saved?.code) {
        // Felder vorfüllen (nice to have)
        if (inpCode) inpCode.value = saved.code;
        if (inpName && saved.name) inpName.value = saved.name;
        // dem Server sagen: ich bin wieder da
        socket.emit('player:hello', { code: saved.code, id: saved.id, name: saved.name });
      }
    } catch {}
    socket.on('ui:refresh', () => { location.reload(); });

    // UI Helpers
    function setJoinLocked(locked) {
      inpCode.disabled = locked;
      inpName.disabled = locked;
      btnJoin.disabled = locked;
      if (locked) btnJoin.textContent = 'Beigetreten';
    }
    function updateBuzz(enabled) {
      canBuzz = !!enabled;
      btnBuzz.disabled = !enabled;
      btnBuzz.classList.toggle('disabled', !enabled);
    }

    // Aktionen
    btnJoin.onclick = () => {
      if (joined || btnJoin.disabled) return;
      btnJoin.disabled = true; // gegen Doppelklick
      socket.emit('player:join', { code: inpCode.value, name: inpName.value });
    };
    btnBuzz.onclick = () => {
      if (!canBuzz || btnBuzz.disabled) return;
      socket.emit('player:buzz');
      updateBuzz(false); // lokal sperren bis Server reagiert
    };
    btnVoteNext.onclick = () => socket.emit('player:vote-next');

    // Runden links rendern
    function renderRounds(playlists = [], activeIndex = 0){
      if (!roundList) return;
      roundList.innerHTML = '';
      playlists.forEach((pl, i) => {
        const div = document.createElement('div');
        div.className = 'item' + (i === activeIndex ? ' active' : '');
        div.textContent = pl.name || `Playlist ${i+1}`;
        roundList.appendChild(div);
      });
    }

    // Songs in der Mitte: N -> 1, aktiver Song zeigt Titel
    function renderSongs(total = 0, active = 0, currentTitle = ''){
      if (!songList) return;
      songList.innerHTML = '';
      for (let i = total; i >= 1; i--) {
        const idxFromTop = i - 1; // 0..N-1 (Song N zuerst)
        const div  = document.createElement('div');
        div.className = 'song' + (idxFromTop === active ? ' active' : '');

        const left  = document.createElement('div');
        left.textContent = `Song ${i}`;

        const right = document.createElement('div');
        right.className = 'badge';
        if (idxFromTop === active && currentTitle) right.textContent = currentTitle;

        div.appendChild(left);
        div.appendChild(right);
        songList.appendChild(div);
      }
    }

    // ── FX: Animation beim Playlist-Wechsel ──────────────────────
    function playlistSwitchFX(){
      const rn    = el('#roundName');
      const songs = el('#songList');
      const list  = el('#roundList');

      // Reflow-Trick, damit die Animation jedes Mal neu startet
      [rn, songs].forEach(n => {
        if (!n) return;
        n.classList.remove('pl-switch');
        void n.offsetWidth;
        n.classList.add('pl-switch');
      });

      // Sidebar: neu aktive Playlist kurz pulsieren lassen
      const active = list?.querySelector('.item.active');
      if (active){
        active.classList.add('just-activated');
        setTimeout(() => active.classList.remove('just-activated'), 900);
      }
    }

    // Spieler- und Punkteliste rechts
    function renderPlayers(players = [], scores = {}){
      const wrap = el('#players');
      if (!wrap) return;
      wrap.innerHTML = '';
      players.forEach(p => {
        const row = document.createElement('div');
        row.className = 'player';
        // wichtig: Daten zum Matching setzen
        row.dataset.pid  = String(p.id ?? '');
        row.dataset.name = p.name ?? '';
        row.innerHTML = `<span>${p.name}</span><strong>${scores[p.id] || 0}</strong>`;
        wrap.appendChild(row);
      });

      // falls schon jemand markiert ist, nach dem Re-Render wieder anwenden
      if (window._lastFirstBuzzer) highlightBuzz(window._lastFirstBuzzer);
    }

    // ── Buzz-Markierung: Zustand + Helper ───────────────────────
    window._lastFirstBuzzer = null;

    function highlightBuzz(by){
      const items = document.querySelectorAll('#players .player');
      items.forEach(div => {
        const matchById   = by?.id   && div.dataset.pid === String(by.id);
        const matchByName = by?.name && (div.dataset.name || div.querySelector('span')?.textContent.trim()) === by.name;
        div.classList.toggle('buzzing', !!(matchById || matchByName));
      });
    }

    function clearHighlight(){
      document.querySelectorAll('#players .player.buzzing')
        .forEach(div => div.classList.remove('buzzing'));
    }

    // --- Socket Events ---

    // Join-Ergebnis (verhindert Doppelbeitritt)
    socket.on('player:join-result', (r) => {
      const st = el('#status');
      if (r.ok){
        joined = true;
        el('#roomCode') && (el('#roomCode').textContent = r.code);
        st && (st.textContent = 'Beigetreten als ' + (r.name || 'Spieler'));
        setJoinLocked(true);      // Felder und Button sperren
        updateBuzz(true);         // Buzz initial erlauben

        // >>> Save for Auto-Resume
        try {
          localStorage.setItem('mq_player', JSON.stringify({ code: r.code, name: r.name, id: r.id }));
        } catch {}
      } else {
        st && (st.textContent = 'Fehler: ' + r.error);
        btnJoin.disabled = false; // erneuten Versuch erlauben
      }
    });

    // Runde/Anzeige aktualisieren, wenn Moderator wechselt
    socket.on('ui:round-update', ({ progress, playlists, activeRound, activeSong, currentTitle }) => {
      const was = window._lastRoundIndex; // vorherige Playlist (beim ersten Mal undefined)
      const rn = el('#roundName');
      if (rn) rn.textContent = progress.roundName;

      renderRounds(playlists, activeRound);
      renderSongs(progress.songTotal, activeSong, currentTitle || '');

      // Wenn sich die Playlist geändert hat → Animation starten
      if (was !== undefined && was !== activeRound) {
        playlistSwitchFX();
      }
      window._lastRoundIndex = activeRound;
    });

    // Neuen Track laden + Titel setzen → Buzz freigeben
    socket.on('round:prepare', ({ src, title }) => {
      if (audio) audio.src = src || '';
      const ct = el('#currentTitle'); if (ct) ct.textContent = title || '–';
      updateBuzz(true);
      const st = el('#status'); if (st) st.textContent = '';
    });

    // Audio nur vom Server
    socket.on('audio:play', () => {
      if (!audio) return;
      allowServerPlay = true;
      audio.play().catch(()=>{}).finally(()=>{ allowServerPlay = false; });
    });
    socket.on('audio:pause', () => { if (audio) audio.pause(); });

    // Blockiere manuelles Play/Pause beim Spieler
    audio?.addEventListener('play', () => { if (!allowServerPlay) audio.pause(); });

    // Buzz-Flow
    socket.on('buzz:first', (payload = {}) => {
      const { name, id } = payload;
      const st = el('#status');
      if (st) st.textContent = `🔔 ${name || 'Ein Spieler'} war zuerst!`;
      updateBuzz(false);

      // merken + markieren
      window._lastFirstBuzzer = (id ? { id, name } : { name });
      highlightBuzz(window._lastFirstBuzzer);
    });

    socket.on('buzz:unlock', () => {
      updateBuzz(true);
      const st = el('#status'); if (st) st.textContent = '';
      clearHighlight();
      window._lastFirstBuzzer = null;
    });

    // Spieler- & Punkte-Updates
    socket.on('room:update', ({ players, scores }) => {
      window._players = players;
      renderPlayers(players, scores || {});
      if (window._lastFirstBuzzer) highlightBuzz(window._lastFirstBuzzer);
    });
    socket.on('scores:update', (scores) => {
      renderPlayers(window._players || [], scores || {});
      if (window._lastFirstBuzzer) highlightBuzz(window._lastFirstBuzzer);
    });

    // Nur Rundennamen refreshen (optional)
    socket.on('progress:update', (p) => {
      const rn = el('#roundName');
      if (rn) rn.textContent = p.roundName;
    });

    // Statusleiste
    socket.on('status', (t) => {
      const st = el('#status');
      if (st) st.textContent = t;
    });
  </script>
</body>
</html>
